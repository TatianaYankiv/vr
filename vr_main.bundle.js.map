{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/aframe-stereo-component/index.js","webpack:///./vr_app/assets-config.js","webpack:///./vr_app/main.js","webpack:///./vr_app/stereo-pair.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iCAAiC;AAC/C,eAAe,iCAAiC;AAChD,gBAAgB;AAChB,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA,QAAQ;;AAER;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;;AAER;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,cAAc;AACd,OAAO;;AAEP;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;;AAER;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuB;AACA;;AAEvB;AACA;AACA;AACA;;AAE8C;;AAE9C;AACA;AACA,WAAW;AACX,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,CAAC;;;AAGD;AACA,SAAS,OAAO;;AAEhB,mBAAmB,0DAAW,cAAc,KAAK;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,oBAAoB,IAAI,IAAI,KAAK;AACjC,GAAG;;AAEH;AACA;AACA;;AAEA,eAAe,0DAAW;;;;;;;;;;;;AC9D1B,sBAAsB,mBAAO,CAAC,gFAAyB;AACvD,yBAAyB,mBAAO,CAAC,gFAAyB;;AAE1D;AACA,0D","file":"vr_main.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./vr_app/main.js\");\n","module.exports = {\n\n   // Put an object into left, right or both eyes.\n   // If it's a video sphere, take care of correct stereo mapping for both eyes (if full dome)\n   // or half the sphere (if half dome)\n\n  'stereo_component' : {\n      schema: {\n        eye: { type: 'string', default: \"left\"},\n        mode: { type: 'string', default: \"full\"},\n        split: { type: 'string', default: \"horizontal\"}\n      },\n       init: function(){\n\n          // Flag to acknowledge if 'click' on video has been attached to canvas\n          // Keep in mind that canvas is the last thing initialized on a scene so have to wait for the event\n          // or just check in every tick if is not undefined\n\n          this.video_click_event_added = false;\n\n          this.material_is_a_video = false;\n\n          // Check if material is a video from html tag (object3D.material.map instanceof THREE.VideoTexture does not\n          // always work\n\n          if(this.el.getAttribute(\"material\")!==null && 'src' in this.el.getAttribute(\"material\") && this.el.getAttribute(\"material\").src !== \"\") {\n            var src = this.el.getAttribute(\"material\").src;\n\n            // If src is an object and its tagName is video...\n\n            if (typeof src === 'object' && ('tagName' in src && src.tagName === \"VIDEO\")) {\n              this.material_is_a_video = true;\n            }\n          }\n\n          var object3D = this.el.object3D.children[0];\n\n          // In A-Frame 0.2.0, objects are all groups so sphere is the first children\n          // Check if it's a sphere w/ video material, and if so\n          // Note that in A-Frame 0.2.0, sphere entities are THREE.SphereBufferGeometry, while in A-Frame 0.3.0,\n          // sphere entities are THREE.BufferGeometry.\n\n          var validGeometries = [THREE.SphereGeometry, THREE.SphereBufferGeometry, THREE.BufferGeometry];\n          var isValidGeometry = validGeometries.some(function(geometry) {\n            return object3D.geometry instanceof geometry;\n          });\n\n          if (isValidGeometry && this.material_is_a_video) {\n\n              // if half-dome mode, rebuild geometry (with default 100, radius, 64 width segments and 64 height segments)\n\n              if (this.data.mode === \"half\") {\n\n                  var geo_def = this.el.getAttribute(\"geometry\");\n                  var geometry = new THREE.SphereGeometry(geo_def.radius || 100, geo_def.segmentsWidth || 64, geo_def.segmentsHeight || 64, Math.PI / 2, Math.PI, 0, Math.PI);\n\n              }\n              else {\n                  var geo_def = this.el.getAttribute(\"geometry\");\n                  var geometry = new THREE.SphereGeometry(geo_def.radius || 100, geo_def.segmentsWidth || 64, geo_def.segmentsHeight || 64);\n              }\n\n              // Panorama in front\n\n              object3D.rotation.y = Math.PI / 2;\n\n              // If left eye is set, and the split is horizontal, take the left half of the video texture. If the split\n              // is set to vertical, take the top/upper half of the video texture.\n\n              if (this.data.eye === \"left\") {\n                var uvs = geometry.faceVertexUvs[ 0 ];\n                var axis = this.data.split === \"vertical\" ? \"y\" : \"x\";\n                for (var i = 0; i < uvs.length; i++) {\n                    for (var j = 0; j < 3; j++) {\n                        if (axis == \"x\") {\n                            uvs[ i ][ j ][ axis ] *= 0.5;\n                        }\n                        else {\n                            uvs[ i ][ j ][ axis ] *= 0.5;\n                            uvs[ i ][ j ][ axis ] += 0.5;\n                        }\n                    }\n                }\n              }\n\n              // If right eye is set, and the split is horizontal, take the right half of the video texture. If the split\n              // is set to vertical, take the bottom/lower half of the video texture.\n\n              if (this.data.eye === \"right\") {\n                var uvs = geometry.faceVertexUvs[ 0 ];\n                var axis = this.data.split === \"vertical\" ? \"y\" : \"x\";\n                for (var i = 0; i < uvs.length; i++) {\n                    for (var j = 0; j < 3; j++) {\n                        if (axis == \"x\") {\n                            uvs[ i ][ j ][ axis ] *= 0.5;\n                            uvs[ i ][ j ][ axis ] += 0.5;\n                        }\n                        else {\n                            uvs[ i ][ j ][ axis ] *= 0.5;\n                        }\n                    }\n                }\n              }\n\n              // As AFrame 0.2.0 builds bufferspheres from sphere entities, transform\n              // into buffergeometry for coherence\n\n              object3D.geometry = new THREE.BufferGeometry().fromGeometry(geometry);\n\n          }\n          else{\n\n              // No need to attach video click if not a sphere and not a video, set this to true\n\n              this.video_click_event_added = true;\n\n          }\n\n\n       },\n\n       // On element update, put in the right layer, 0:both, 1:left, 2:right (spheres or not)\n\n       update: function(oldData){\n\n            var object3D = this.el.object3D.children[0];\n            var data = this.data;\n\n            if(data.eye === \"both\"){\n              object3D.layers.set(0);\n            }\n            else{\n              object3D.layers.set(data.eye === 'left' ? 1:2);\n            }\n\n       },\n\n       tick: function(time){\n\n           // If this value is false, it means that (a) this is a video on a sphere [see init method]\n           // and (b) of course, tick is not added\n\n           if(!this.video_click_event_added){\n                if(typeof(this.el.sceneEl.canvas) !== 'undefined'){\n\n                   // Get video DOM\n\n                   this.videoEl = this.el.object3D.children[0].material.map.image;\n\n                   // On canvas click, play video element. Use self to not lose track of object into event handler\n\n                   var self = this;\n\n                   this.el.sceneEl.canvas.onclick = function () {\n                      self.videoEl.play();\n                   };\n\n                   // Signal that click event is added\n                   this.video_click_event_added = true;\n\n                }\n           }\n\n       }\n     },\n\n  // Sets the 'default' eye viewed by camera in non-VR mode\n\n  'stereocam_component':{\n\n      schema: {\n        eye: { type: 'string', default: \"left\"}\n      },\n\n       // Cam is not attached on init, so use a flag to do this once at 'tick'\n\n       // Use update every tick if flagged as 'not changed yet'\n\n       init: function(){\n            // Flag to register if cam layer has already changed\n            this.layer_changed = false;\n       },\n\n       tick: function(time){\n\n            var originalData = this.data;\n\n            // If layer never changed\n\n            if(!this.layer_changed){\n\n            // because stereocam component should be attached to an a-camera element\n            // need to get down to the root PerspectiveCamera before addressing layers\n\n            // Gather the children of this a-camera and identify types\n\n            var childrenTypes = [];\n\n            this.el.object3D.children.forEach( function (item, index, array) {\n                childrenTypes[index] = item.type;\n            });\n\n            // Retrieve the PerspectiveCamera\n            var rootIndex = childrenTypes.indexOf(\"PerspectiveCamera\");\n            var rootCam = this.el.object3D.children[rootIndex];\n\n            if(originalData.eye === \"both\"){\n                rootCam.layers.enable( 1 );\n                rootCam.layers.enable( 2 );\n              }\n              else{\n                rootCam.layers.enable(originalData.eye === 'left' ? 1:2);\n              }\n            }\n       }\n\n  }\n};\n","const ROOM_1 = {\n    name: 'room_1',\n    url: './img/vr_app/my_room.jpg',\n    arrows: [\n      {\n        attr: {\n          position: '50 10 -50',\n          rotation: \"0 0 90\",\n          src: \"#arrow-right\",\n          width: \"10\",\n          height: \"10\",\n        },\n        data: {\n          next: 'room_2',\n        }\n      },\n      /* {\n        attr: {\n          position: '15 0.25 10',\n          rotation: \"0 0 90\",\n          src: \"#arrow-right\",\n          width: \"5\",\n          height: \"5\",\n        },\n        data: {\n          next: 'room_2',\n        }\n      } */\n    ]\n}\nconst ROOM_2 = {\n    name: 'room_2',\n    url: './img/vr_app/Bathroom.jpg',\n    arrows: [\n      {\n        attr: {\n          position: '20 5 -33',\n          rotation: \"0 0 90\",\n          src: \"#arrow-right\",\n          width: \"5\",\n          height: \"5\",\n        },\n        data: {\n          next: 'room_3',\n        }\n      },\n    ]\n}\nconst ROOM_3 = {\n  name: 'room_3',\n  url: './img/vr_app/Bedroom.jpg',\n  arrows: [\n    {\n    attr: {\n      position: '-110 0 -50',\n      rotation: '1 10 90',\n      src: \"#arrow-right\",\n      width: \"10\",\n      height: \"10\",\n    },\n    data: {\n      next: 'room_2',\n    }\n    },\n\n  ]\n}\n\nexport const APARTMENT_1 = {\n  name: 'APARTMENT_1',\n  rooms: [\n    ROOM_3,\n    ROOM_2,\n    ROOM_3,\n  ]\n};\n","import './stereo-pair';\nimport './device_move';\n\nconst SKY_LEFT = document.querySelector('a-sky.left');\nconst SKY_RIGHT = document.querySelector('a-sky.right');\nconst SCENE = document.querySelector('a-scene');\nconst NEXT_ROOM = 'next-room';\n\nimport { APARTMENT_1 } from './assets-config';\n\nAFRAME.registerComponent('next-room', {\n  schema: {\n    next: {type: 'string'}\n  },\n  init: function () {\n    this.listener = onArrowClick.bind(this);\n    this.el.addEventListener('click', this.listener);\n  },\n  remove() {\n    this.el.removeEventListener('click', this.listener);\n  },\n});\n\n\nfunction onArrowClick() {\n  const { data } = this;\n\n  const nextRoom = APARTMENT_1.rooms.find(({name}) => name === data.next);\n\n  setUpRoom(nextRoom);\n}\n\nfunction buildApartment(app) {\n  const initialRoom = app.rooms[0];\n\n  setUpRoom(initialRoom);\n}\n\nfunction setUpRoom(room) {\n  document.querySelectorAll('[next-room]').forEach(el => el.remove());\n  SKY_LEFT.setAttribute('src', room.url);\n  SKY_RIGHT.setAttribute('src', room.url);\n\n  room.arrows.forEach(arrowConfig => {\n    SCENE.appendChild(buildArrow(arrowConfig));\n  })\n}\n\nfunction buildArrow(config) {\n  const aImage = document.createElement('a-image');\n  Object.entries(config.attr).forEach(([key, val]) => {\n    aImage.setAttribute(key, val);\n  })\n\n  const dataString = Object.entries(config.data).reduce((acc, [key, val]) => {\n    return acc + `${key}: ${val};`;\n  }, '')\n\n  aImage.setAttribute(NEXT_ROOM, dataString);\n  return aImage;\n}\n\nbuildApartment(APARTMENT_1);\n","var stereoComponent = require('aframe-stereo-component').stereo_component;\r\nvar stereocamComponent = require('aframe-stereo-component').stereocam_component;\r\n\r\nAFRAME.registerComponent('stereo', stereoComponent);\r\nAFRAME.registerComponent('stereocam', stereocamComponent);"],"sourceRoot":""}